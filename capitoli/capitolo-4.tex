% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Progettazione e codifica}
\label{cap:progettazione-codifica}
%**************************************************************

\intro{Tale capitolo descrive in dettaglio la struttura del progetto, la progettazione e codifica delle nuove funzionalità e nonchè l'integrazione di esse con la struttura preesistente. La fase di progettazione e codifica non sono intese come attività prettamente distinte, infatti alcune analisi effettuate durante la progettazione iniziale antecedente alla codifica sono risultate non sufficienti a coprire numerose casistiche sorte durante lo sviluppo effettivo, per cui è stato necessario una riprogettazione mirata a risolvere le problematiche sorte.}\\

\section{Adattamento degli operatori preesistenti}
Durante l'analisi preventiva dei rischi relativa alle nuove funzionalità, sono sorti subito dei problemi relativi all'adattabilità degli operatori preesistenti con la nuove funzionalità create. Tali problematiche di adattabilità si possono riassumere in micro-aree:

\begin{itemize}
	\item{adattabilità della rappresentazione degli eventi tramite l'output dell'operatore \textbf{Bumblebee} definito come \textbf{BumblebeeOuput}, che va a definire la trasformazione degli eventi "grezzi" in eventi arracchiti da informazioni necessarie per il loro processamento;}
	\item{adattabilità dell'\textbf{operatore di windowing} che ora non devo solo trattare aggreazione di eventi ricevuti dallo stesso tipo di risorsa, ma deve gestire l'aggregazione e/o l'allineamento anche di risorse di tipo differente per permettere all'operatore di \textit{Anomaly Detector} di eseguire un controllo a livello di insieme relativo a risorse differenti;}
	\item{adattabilità dell'operatore \textbf{Anomaly Detector} per permettere ad esso di gestire e di controllare gruppi di eventi derivanti da risorse non più eguali fra di loro. Quindi di gestire il controllo relativo alla presenza di una anomalia relativa ad un gruppo di risorse. Inoltre, tale operatore, deve adattarsi anche alla presenze di due nuovi \textit{detector} di anomalie, quali \textbf{Unsupervised} e \textbf{Rule based}.}
\end{itemize}
	
Nello specifico si va ad analizzare le modifiche adottate riguardo le tre micro-aree descritte precedentemente.

\section{Operatore Bumblebee}\label{sec:bbout}
Per permettere la rappresentazione di gruppi di risorse differenti, viene cambiata la struttura dell'output dell'operatore \textbf{Bumblebee}, rappresententato inizialmente in un formato \gls{json} così rappresentato:

\begin{minted}{js}
{
  "id": // id dell'evento, generato o trasformato dall'evento originale, in formato String,
  "pipeID": // id della pipeline, in formato String,
  "pipeVersion": //versione della pipeline, in formato String,
  "adapterID": //id dell'adattatore, in formato String,
  "tid": //id del cliente, in formato String,
  "assetID": //id della risorsa, in formato String,
  "ts": //timestamp dell'evento, in formato String,
  "asset": //informazioni relative alla risorsa dopo che è stata arricchita, in formato AssetInfo
  "data": //payload dei dati dell'evento trasformati in formato JSON,
  "ctxData": //dati relativi al contesto, come per esempio il tempo metereologico, in formato JSON,
  "meta": //metadati arricchiti dall'operatore di anomaly detection, in formato Option[EventMeta],
  "type": //tipo di BumblebeeOutput", in formato Option[String],
  "srcID": //id della fonte dell'evento in formato String
}
\end{minted}

Dopo l'opportuna modifica, la struttura rappresentate il \textbf{BumblebeeOutput} è così formata:

\begin{minted}{js}
{
  "id": // id dell'evento, generato o trasformato dall'evento originale, in formato String,
  "pipeID": // id della pipeline, in formato String,
  "pipeVersion": //versione della pipeline, in formato String,
  "adapterID": //id dell'adattatore, in formato String,
  "tid": //id del cliente, in formato String,
  "subject": {
	  "id": //id dell'oggetto, in formato String,
	  "type": //tipo dell'oggetto rapresentanto (asset,category,group), in formato String
  }
  "ts": //timestamp dell'evento, in formato String,
  "asset": //informazioni relative alla risorsa dopo che è stata arricchita, in formato AssetInfo
  "data": //payload dei dati dell'evento trasformati in formato JSON,
  "ctxData": //dati relativi al contesto, come per esempio il tempo metereologico, in formato JSON,
  "meta": //metadati arricchiti dall'operatore di anomaly detection, in formato Option[EventMeta],
  "type": //tipo di BumblebeeOutput", in formato Option[String],
  "srcID": //id della fonte dell'evento in formato String
}
\end{minted}
dove la rappresentazione è slegata da un \textit{asset} (risorsa) specifico. Per cui l'output sarà adattato ad un \textit{soggetto} generale, rappresentato da un proprio \textbf{id} e da un suo \textbf{tipo}.
Tale struttura finale garantisce una corretto processamento del dato nel caso in cui si tratti di una risorsa singola oppure di un raggruppamento di quest'ultime.

\section{Operatore Windowing}
L'\textbf{operatore Windowing} serve per rappresentare un determinato evento in una data finestra temporale. Inizialmente, tale operatore, trattava l'aggregazione solo di una determinata \textit{risorsa} su se stessa, cioè \textit{sommando} o \textit{mediando} un determinato valore. Ora in tale operatore non solo permane il comportamento appena descritto, ma è presente anche la funzionalità che si occupa di allineare e/o aggregare fra di loro \textit{risorse} di tipo differente, per permettere un processamento dei dati a livello collettivo. Per definire il comportamento della finestra temporale, è necessaria un apposita \textbf{configurazione} che sarà iniettata durante il processamento attivo dei dati, per permetterne la modifica del comportamento senza dover riavviare l'intero applicativo e creare uno stallo in esso.\\
L'operatore Windowing è una \textbf{KeyedCoProcessFunction}, così definita:
\begin{minted}{scala}
class Windowing(outputTagValues: OutputTag[AnomalyStepConfigurationCommand]) extends KeyedCoProcessFunction[String, BumblebeeOutput, AnomalyStepConfigurationCommand, GroupedEvents] {
	// ...
  }
\end{minted}
Dove in entrata avrà due tipi di flussi, uno relativo agli eventi da raggruppare di tipo \textit{BumblebeeOutput} (\S\ref{sec:pr1-windowing}) e uno relativo alla \textit{configurazione} della finestra temporale (\S\ref{sec:pr2-windowing}). Tale operatore operato su flussi suddivisi per chiave definita come \textbf{pipeID}. Infine il metodo che verrà richiamato alla fine di una specifica finestra temporale è il metodo \textit{onTimer} (\S\ref{sec:on-timer-windowing}), il quale collezionerà gli eventi all'interno della window appena conclusa e programmerà l'inizio della successiva finestra temporale.

\subsection{Stati dell'operatore}\label{sec:stati-windowing}
Per permettere una corretta gestione di entrambi i flussi, l'operatore \textit{Windowing} sfrutta i seguenti \textbf{stati} interni:
\begin{itemize}
		\item{\textbf{configurazione della window:} l'attuale configurazione della finestra temporale;}
		\item{\textbf{mappa degli aggregatori:} mappa che gestisce gli aggregatori (\S\ref{sec:aggregator}), i quali sono mappati per l'id del gruppo;}
		\item{\textbf{mappa degli eventi futuri:} mappa che gestisce la lista degli eventi arrivati in anticipo, i quali sono mappati per l'id del gruppo;}
		\item{\textbf{inizio della finestra temporale:} l'inizio dell'attuale finestra temporale;}
		\item{\textbf{timer:} timer schedulato per collezionare gli eventi visti dalla window, il quale coincide con la fine dell'attuale finestra temporale;}
		\item{\textbf{stato della \gls{pipeline}:} mappa che gestisce la versione delle varie \gls{pipeline}, le quali sono mappate per l'id della \gls{pipeline}.}
\end{itemize}


\subsection{Flusso degli eventi da raggruppare}\label{sec:pr1-windowing}
Tale flusso è gestito dal metodo \textit{processElement1}, il quale è un metodo ereditato dalla classe \textbf{KeyedCoProcessFunction} e sovrascritto dalla classe rappresentate l'operatore (\textit{Windowing}). Il flusso attuale dell'operatore prevede questi step:

\begin{enumerate}
	\item{arrivo dell'\textit{evento} di tipo \textit{BumblebeeOutput};}
	\item{controllo relativo a se la configurazione è presente, nel caso in cui non sia presente si saltano tutti i passaggi successivi e l'evento viene ignorato;}
	\item{per ogni gruppo contenuto all'interno del filtro di aggregazione della window verrà fatto il controllo per verificare che quel determinato gruppo è filtrato per accettare quel determinato evento in entrata;}
\item{se l'evento è contenuto all'interno del filtro di un gruppo, viene controllata se la durata della window è nulla (minore o uguale a zero), in questa casistica l'evento viene collezionato all'interno della struttura dati rappresentata dal \textit{GroupedEvents} (\S\ref{sec:ge}) senza essere aggregato o allineato con altri eventi. Il flusso relativo all'evento entrante termina;}
\item{se la durata della window ha una durata non nulla (maggiore di zero), l'evento verrà inserito nell'attuale window se il suo \gls{timestamp} è contenuto nei limiti di essa (inizio e fine). Se, invece, l'evento è antecedente all'inizio della window, viene scartato. Infine, se l'evento è successivo alla fine della window, verrà inserito in un apposita struttura dati rappresentate gli \textit{"eventi futuri"}, i quali verranno trattati nella successiva window.}
\end{enumerate}

Per gestire l'inizio di una determinata nuova finestra temporale (quindi basata su una nuova \textbf{configurazione} per essa) verrà fatto un controllo per definire se l'evento entrante è il primo a partire da una nuova configurazione. In questo caso l'inizio della window è eguale al \gls{timestamp} dell'evento entrante e la fine della window è equivalente alla somma dell'inizio della window con la sua durata (definita nella configurazione).
\subsection{Flusso di configurazione della window}\label{sec:pr2-windowing}
Tale flusso è gestito dal metodo \textit{processElement2}, il quale è un metodo ereditato dalla classe \textbf{KeyedCoProcessFunction} e sovrascritto dalla classe rappresentate l'operatore (\textit{Windowing}). Il flusso attuale dell'operatore prevede questi step:

\begin{enumerate}
	\item{arrivo dell'evento riguardate la \textit{configurazione} di tipo \textit{AnomalyStepConfiguration};}
	\item{controllo relativo a se la configurazione è di tipo "\textit{update}" o "\textit{delete}". In caso la configurazione non rappresenti nessuno dei due casi appena citati il flusso termina collezionando l'evento in un \textit{SideOutput}, cioè un coda differente rispetto a quella principale relativa ai \textit{GroupedEvents} (\S\ref{sec:ge}). Tale coda tratta gli eventi di tipo \textit{AnomalyStepConfiguration}}
	\item{Nel caso in cui la configurazione comprenda uno dei due tipi citati nel punto precedente, verrà fatto un controllo per verificare che la configurazione \textbf{relativa alla window} sia presente e sia diversa da quella precedente, il che significa che la configurazione precedente è inesistente o che quella precedente si differenzia da quella attuale per almeno una di queste condizioni:
	\begin{itemize}
		\item{differente durata della finestra temporale;}
		\item{differente metodo di aggregazione;}
		\item{differente lista di gruppi su cui lavorerà la window;}
		\item{differenti parametri \textbf{relativi ai dati degli eventi} su cui si andrà a fare l'aggregazione;}
		\item{differenti \textbf{parametri del contesto} relativi agli eventi su cui si andrà a fare l'aggregazione.}
	\end{itemize}
	
Se la configurazione della window è differente da quella precedente, vengono svuotati i relativi stati dell'operatore su cui opera la finestra temporale, quali \textbf{mappa degli aggregatori}, \textbf{mappa degli eventi futuri}, \textbf{inizio della finestra temporale} e \textbf{timer}. Di seguito viene aggiornato lo stato relativo alla \textbf{configurazione della window} con i dati della finestra temporale nuova.\\
Se, invece, la nuova configurazione della finestra temporale è equivalente a quella precedente, non viene fatto nulla.\\
Infine viene aggiornato lo \textbf{stato della \gls{pipeline}}.\\
Per una descrizione approfondita degli stati dell'operatore Windowing fare riferimento alla sezione (\S\ref{sec:stati-windowing})
}
\item{Se invece la \textbf{configurazione della window} non esiste, verrano svuotati tutti gli stati presenti nella sezione \S\ref{sec:stati-windowing}.}
\end{enumerate}

\subsection{OnTimer}\label{sec:on-timer-windowing}
Il metodo \textit{onTimer} è colui che gestisce la logica al termine di ogni finestra temporale. Tale funzione si occupa di creare un \textit{GroupedEvents} (\S\ref{sec:ge}) collezionando gli eventi visti secondo le regole definite dalla configurazione e ha il compito di configurare la prossima window. Il metodo segue questi step:
\begin{enumerate}
	\item{controllo relativo a se la configurazione della finestra temporale è settata, in caso negativo vengono saltati tutti gli step successivi;}
	\item{in base alla modalità di aggregazione definita nella configurazione della finestra temporale, per ogni \textbf{id del gruppo} contenuto all'interno dello stato relativo alla \textbf{mappa degli aggregatori} verrà creato e collezionato un \textit{GroupedEvents} (\S\ref{sec:ge}) contenente gli eventi aggregati o allineati secondo la modalità definita. Per la logica di aggregazione vedere la sezione \S\ref{sec:aggregator};}
	\item{Creazione della nuova finestra temporale, cui l'inizio e la fine sono impostati rispettivamente con il \gls{timestamp} che ha attivato il timer e tale \gls{timestamp} sommato alla durata della window. Di seguito, viene svuotata la \textbf{mappa degli aggregatori} che non contengono eventi inseriti nello stato \textbf{mappa degli eventi futuri} che risiedo nella nuova finestra temporale (nel caso in cui siano presenti degli eventi futuri, verrà istanziato un nuovo aggregatore contente già questi eventi). Infine viene svuotato lo stato relativo alla \textbf{mappa degli eventi futuri}.
	}
\end{enumerate}

\subsection{GroupedEvents}\label{sec:ge}
L'ouput dell'operatore, dapprima rappresentava solo una \textbf{risorsa singola}, ora invece tratterà un \textit{gruppo}, il quale è identificato da un \textbf{id}, da un \textbf{\gls{timestamp}} e da un \textbf{array} di \textit{risorse} di tipo \textit{BumblebeeOutput}.\\
L'OutputWindow può rappresentare logicamente tre tipi logici di dato:
\begin{itemize}
	\item{\textbf{elemento singolo:} dove l'\textit{array} degli eventi è formato \textit{1} elemento, l'\textit{id del gruppo} equivale all'id della risorsa dell'unico evento all'interno dell'array e il \textit{\gls{timestamp}} equivale al \gls{timestamp} dell'unico evento all'interno dell'\textit{array};}
	\item{\textbf{singolo elemento aggregato:} dove l'\textit{array} degli eventi è formato da \textit{1} elemento, l'\textit{id del gruppo} equivale all'id definto dalla configurazione e il \textit{\gls{timestamp}} equivale a quello definito durante l'aggregazione effettiva;}
	\item{\textbf{allineamento:} dove l'\textit{array} degli eventi è formato da \textit{N} elementi, l'\textit{id del gruppo} equivale all'id definto dalla configurazione e il \textit{\gls{timestamp}} equivale a quello definito durante l'aggregazione effettiva;}
\end{itemize}

\subsection{Aggregatore}\label{sec:aggregator}




\section{Operatpre Anomaly Detector}
L'operatore \textbf{Anomaly Detector} è colui che si occupa di sollevare segnalazioni nel caso sia presente un'anomalia riguardo l'evento entrante (di tipo \textbf{OutputWindow}). Dapprima il l'Anomaly Detector lavorava solo su un tipo di evento legato ad una \textit{risorsa} singola, mappando l'\textit{id del detector} ad un'altra mappa dove la chiave è rappresentata dall'\textit{id della risorsa} e il valore è rappresentato dal vero e proprio \textit{detector}. Ora invece la struttura è basata sull'\textit{id del gruppo}, per cui è stata creata un'ulteriore mappa fra \textit{id del gruppo} e \textit{id del detector}, inoltre la chiave della mappa interna non è più rappresentata da un'id della risorsa, ma da un \textit{id dell'oggetto} dopo la modifica di \textbf{BumblebeeOutput} \S\ref{sec:bbout}.\\
I \textit{detector} ora avranno un parametro in più che permette di definire se un determinato detector valuta l'anomalia su un gruppo di risorse o su una risorsa singola.\\
Di seguito la lista dei detector:
\begin{itemize}
	\item{\textbf{Uniseas}: detector che lavora singolarmente su un tipo di risorsa;}
	\item{\textbf{Crosscorel}: detector che lavora singolarmente su un tipo di risorsa e su un evento esterno ad essa (come per esempio il tempo metereologico);}
	\item{\textbf{Siblings}: detector che lavora singolarmente su un tipo risorsa valutando il suo andamento su \textit{N} risorse uguali ad essa. Utilizza un algoritmo di \textit{\gls{Apprendimento automatico}} di tipo \textit{\gls{Apprendimento supervisionato}};}
	\item{\textbf{Unsupervised}: detector che lavora su un gruppo di risorse lavorando con un algoritmo di \textit{\gls{Apprendimento automatico}} di tipo \textit{\gls{Apprendimento non supervisionato}};}
	\item{\textbf{Rule based}: detector che lavora su un gruppo di risorse oppure su una risorsa singola in base alla propria configurazione e valutando l'andamento della/e risorsa/e tramite una regola definita dall'utente.}
\end{itemize}

La modifica apportata al codice sostanzialmente tratta il controllo da effettuare (in base alla \textit{configurazione} del detector) per definire su quale dato processare l'anomalia, nel caso avvenga. Infatti nel caso di un gruppo verrà creato un evento rappresentante tale gruppo su cui sollevare l'anomalia, invece nel caso di una risorsa singola l'anomalia verrà sollevata sull'evento relativa ad essa. 



%**************************************************************
\section{Ciclo di vita del software}
\label{sec:ciclo-vita-software}

%**************************************************************
\section{Progettazione}
\label{sec:progettazione}

\subsubsection{Namespace 1} %**************************
Descrizione namespace 1.

\begin{namespacedesc}
    \classdesc{Classe 1}{Descrizione classe 1}
    \classdesc{Classe 2}{Descrizione classe 2}
\end{namespacedesc}


%**************************************************************
\section{Design Pattern utilizzati}

%**************************************************************
\section{Codifica}
