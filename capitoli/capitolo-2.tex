% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Strumenti e tecnologie utilizzate}
\label{cap:strumenti-tecnologie}

%**************************************************************

\intro{Tale capitolo racchiude gli strumenti utilizzati e le tecnologie impiegate durante la realizzazione di \myTitle. In particolare verra analizzato il dominio di utilizzo di esse e le varie meotodologie utilizzate.}\\

%**************************************************************
\section{Apache Flink}
Apache Flink è un \gls{framework} di \textit{data processing engine} per l'elaborazione e processamento di dati in modo distribuito.
La forza di Flink è quella di trattare dati in differenti formati, opportuni per il dominio applicativo più consono per l'utente, infatti i dati possono essere di tipo \gls{stateful} che \gls{stateless} e tali flussi possono essere illimitati (\gls{unbounded streams}) o limitati (\gls{bounded streams}). Flink è stato progettato per funzionare in tutti i comuni ambienti \gls{cluster}.

\subsection{DataStream API}
\subsubsection{Flussi illimitati (unbounded)}
\subsubsection{Flussi limitati (bounded)}

\subsection{Table API}

\subsection{Operatori}
Gli operatori di Flink sono delle procedure per trasformare DataStream in altri DataStream. Sono utilizzati principalmente per modificare il tipo di flusso di un DataStream, il quale appunto verrà filtrato, mappato o combinato con altri flussi per produrre un altro DataStream. Nelle sezioni sottostanti verranno descritti i principali operatori utilizzati, i quali non rappresentano la totalità degli operatori disponibili. Per l'elenco completo si rimanda alla documentazione ufficiale di Apache Flink.

\subsubsection{FlatMap}
Operatore che dato un elemento, ne produce in output uno, zero o molteplici. Tale operatore trasformerà un dato \textit{DataStream} in un altro \textbf{DataStream}. La procedura di trasformazione è definita dall'utente e per ogni elemento del DataStream verrà applicata tale logica per andare a definire l'output atteso. Di seguito la struttura appena descritta.

\begin{minted}{scala}
dataStream.flatMap { str => str.split(" ")}
\end{minted}
	
	
\subsubsection{CoFlatMap}
Operatore che dato un elemento, ne produce in output uno, zero o molteplici. Tale operatore trasforma un \textit{ConnectedStream} in un \textbf{DataStream}. La differenza con l'operatore \textbf{FlatMap} è che tale operatore lavorerà su due DataStream connessi fra di loro, e come per l'operatore nella sezione precedente, verrà prodotto in output un unico DataStream secondo una logica definita dall'utente. Di seguito la struttura appena descritta.

\begin{minted}{scala}
connectedStreams.flatMap(
    (_ : Int) => true,
    (_ : String) => false
)
\end{minted}

\subsubsection{KeyBy}
Operatore che suddivide un flusso in partizione disgiunte. Tale operatore trasforma un \textit{DataStream} in un \textit{KeyedStream} trattando gli elementi che hanno chiave uguale nella stessa partizione. Internamente, \textit{keyBy()} è implementato con il partizionamento hash.
La chiave deve essere intesa come univoca.
Di seguito la struttura appena descritta.
\begin{minted}{scala}
dataStream.keyBy(_.someKey)
dataStream.keyBy(_._1)
\end{minted}
\subsubsection{Timer}
\subsubsection{ProcessFunction}


\subsection{Alta disponibilità e recovery}

\subsubsection{Stateful e Stateless}

\subsubsection{Savepoint e Checkpoint}

\subsection{Serializzazione}

\subsubsection{Avro}

\subsubsection{Kryo}


\subsection{Scalabilità}


\section{Scala}

\section{Amazon Kinesis}

