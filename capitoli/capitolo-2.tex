% !TEX encoding = UTF-8
% !TEX TS-program = pdflatex
% !TEX root = ../tesi.tex

%**************************************************************
\chapter{Strumenti e tecnologie utilizzate}
\label{cap:strumenti-tecnologie}

%**************************************************************

\intro{Tale capitolo racchiude gli strumenti utilizzati e le tecnologie impiegate durante la realizzazione di \myTitle. In particolare verra analizzato il dominio di utilizzo di esse e le varie meotodologie utilizzate.}\\

%**************************************************************
\section{Apache Flink}
\textit{Apache Flink} è un \gls{framework} di \textit{data processing engine} per l'elaborazione e processamento di dati in modo distribuito.
La forza di Flink è quella di trattare dati in differenti formati, opportuni per il dominio applicativo più consono per l'utente, infatti i dati possono essere di tipo \gls{stateful} che \gls{stateless} e tali flussi possono essere illimitati (\gls{unbounded streams}) o limitati (\gls{bounded streams}). Flink è stato progettato per funzionare in tutti i comuni ambienti \gls{cluster}.

\subsection{DataStream e DataStrem API}
In Apache Flink i dati processati in un programma vengono rappresentati dalla classe speciale \textit{DataStream}.
Tali dati possono essere finiti o illimitati, e le \gls{api} utilizzate per lavorare su questi due differenti tipoligie di dati è la stessa, rendendo il tutto trasparente per l'utente programmatore.\\
Carattestiche fondamentali dei DataStream sono:
\begin{itemize}
	\item{\textbf{immutabilità:} una volta creati non è possibile aggiungere o rimuovere elementi;}
	\item{\textbf{soggetti a trasformazioni:} non è possibile ispezionare gli elementi al proprio interno, ma solo lavorare su di essi utilizzando le \textit{DataStream \gls{api}}, che vengono definite, appunto, trasformazioni.}
\end{itemize}
La creazione di un DataStream necessità di avere una sorgente iniziale (la quale può essere, per esempio, una coda \gls{kafka}) e da questo si possono derivare numerosi flussi e combinarli utilizzando le \gls{api} esposte, nonchè gli operatori descritti nella sezione \S\ref{sec:operatori}.
Le DataStream \gls{api} supportano differenti modalità di esecuzione, le quali permettono di avere un approccio più mirato in base all'utilizzo effettivo dell'utente.\\
Le modalità principali di esecuzione sono:
\begin{itemize}
	\item{\textbf{Esecuzione streaming:} tratta principalmente di flussi illimitati (\gls{unbounded streams}) i quali hanno la caratteristica di non terminare mai. I dati vengono processati ininterrottamente, continuando ad aggiornare l'ouput prodotto. In questa modalità le attività esecutive all'interno della \gls{pipeline} del programma continuano ad essere processate in contemporanea, senza stanziarsi in una fase specifica. Questo implica che la \gls{pipeline} non arriverà mai ad uno stadio di terminazione;}
	\item{\textbf{Esecuzione batch:} tratta solo flussi limitati (\gls{bounded streams}). Questa procedura permette a Flink di ottimizzare l'esecuzione basandosi sul flusso conosciuto, il quale ha un'inizio ed una fine. In questa modalità le varie attività all'interno della \gls{pipeline} del programma possono essere eseguite una dopo l'altra, permettendo di passare alla fase successiva solo quando si è terminata quella precedente (quindi non in contemporanea come avviene per l'esecuzione streaming). I dati fra una fase ed un'altra vengono salvati in una memoria non temporanea per permettere a Flink di ripartire da un determinato step senza rieseguire l'intero programma.}
\end{itemize}

\subsection{Table API}

\subsection{Operatori}\label{sec:operatori}
Gli operatori di Flink sono delle procedure per trasformare DataStream in altri DataStream. Sono utilizzati principalmente per modificare il tipo di flusso di un DataStream, il quale appunto verrà filtrato, mappato o combinato con altri flussi per produrre un altro DataStream. Nelle sezioni sottostanti verranno descritti i principali operatori utilizzati, i quali non rappresentano la totalità degli operatori disponibili. Per l'elenco completo si rimanda alla documentazione ufficiale di Apache Flink.

\subsubsection{FlatMap}
Operatore che dato un elemento, ne produce in output uno, zero o molteplici. Tale operatore trasformerà un dato \textit{DataStream} in un altro \textbf{DataStream}. La procedura di trasformazione è definita dall'utente e per ogni elemento del DataStream verrà applicata tale logica per andare a definire l'output atteso. Di seguito la struttura appena descritta.

\begin{minted}{scala}
dataStream.flatMap { str => str.split(" ")}
\end{minted}
	
	
\subsubsection{CoFlatMap}
Operatore che dato un elemento, ne produce in output uno, zero o molteplici. Tale operatore trasforma un \textit{ConnectedStream} in un \textbf{DataStream}. La differenza con l'operatore \textbf{FlatMap} è che tale operatore lavorerà su due DataStream connessi fra di loro, e come per l'operatore nella sezione precedente, verrà prodotto in output un unico DataStream secondo una logica definita dall'utente. Di seguito la struttura appena descritta.

\begin{minted}{scala}
connectedStreams.flatMap(
    (_ : Int) => true,
    (_ : String) => false
)
\end{minted}

\subsubsection{KeyBy}
Operatore che suddivide un flusso in partizione disgiunte. Tale operatore trasforma un \textit{DataStream} in un \textit{KeyedStream} trattando gli elementi che hanno chiave uguale nella stessa partizione. Internamente, \textit{keyBy()} è implementato con il partizionamento hash.
La chiave deve essere intesa come univoca.
Di seguito la struttura appena descritta.
\begin{minted}{scala}
dataStream.keyBy(_.someKey)
dataStream.keyBy(_._1)
\end{minted}

\subsubsection{ProcessFunction}
Operatore di basso livello che da accesso ai blocchi base di uno \textit{Stream}:
\begin{itemize}
	\item{\textbf{eventi:} elementi dello \textit{Stream};}
	\item{\textbf{stati:} stati tolleranti agli errori, consistenti e supportati solo nei \textit{Keyed Stream}. La \textit{ProcessFunction} da accesso allo stato tramite il \textit{RuntimeContext}, in modo simile a quanto avviene negli altri operatori che hanno accesso allo stato;}
	\item{\textbf{timer:} tempo relativo all'evento e tempo relativo al processamento dei dati, anch'esso supportato solo nei \textit{Keyed Stream}}. Per una descrizione più approfondità del timer farè riferimento alla sezione \S\ref{sec:timer}
\end{itemize}

Per creare una \textit{ProcessFunction}, bisogna implementare il metodo astratto \textit{processElement}, nella quale va implementata la logica di gestione degli elementi. Inoltre, per usufruire dello \textit{state} e del \textit{timer}, come descritto precedentemente, bisogna basarsi su un \textit{Keyed Stream}, quindi al posto di trattare la \textit{ProcessFunction} di per sè, si va a lavoare con la \textit{KeyedProcessFunction}, la quale è un estensione della \textit{ProcessFunction} e permette l'accesso alla chiave del timer nel metodo \textit{onTimer} 

\myParagraph{Timer}\label{sec:timer}
Tutti e due i tipi di timer (tempo relativo all'evento e tempo relativo processamento di tale) sono gestiti dal \textit{TimeService}. Ogni volta che viene chiamato l'operato \textit{ProcessElement} viene fornito un oggetto chiamato \textit{Context} il quale da accesso al \gls{timestamp} relativo all'evento e ad un oggetto chiamato \textit{TimeService}, il quale permette di registrare il timer per permettere future elaborazioni. Per ogni coppia \textit{chiave}-\gls{timestamp} esiste un solo timer, se più timer sono settati per lo stesso \gls{timestamp}, solo uno verrà richiamato. Flink sincronizza internamente l'invocazione della funzione \textit{processElement} e \textit{onTimer}, rendendo tale sincronizzazione trasparente per l'utente. I timer sono tolleranti verso gli errori, infatti Flink salva tale timer tramite il meccanismo di \gls{checkpoint} come avviene per gli stati.

\subsection{Alta disponibilità e recovery}

\subsubsection{Stateful e Stateless}

\subsubsection{Savepoint e Checkpoint}

\subsection{Serializzazione}

\subsubsection{Avro}

\subsubsection{Kryo}


\subsection{Scalabilità}


\section{Scala}

\section{Amazon Kinesis}

